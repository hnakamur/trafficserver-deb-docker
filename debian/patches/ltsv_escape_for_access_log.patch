diff --git a/include/proxy/logging/LogField.h b/include/proxy/logging/LogField.h
index 0498b3f97..249402d28 100644
--- a/include/proxy/logging/LogField.h
+++ b/include/proxy/logging/LogField.h
@@ -32,7 +32,7 @@
 #include "proxy/logging/LogFieldAliasMap.h"
 #include "proxy/Milestones.h"
 
-enum LogEscapeType { LOG_ESCAPE_NONE, LOG_ESCAPE_JSON };
+enum LogEscapeType { LOG_ESCAPE_NONE, LOG_ESCAPE_JSON, LOG_ESCAPE_LTSV };
 
 class LogAccess;
 
diff --git a/src/proxy/logging/LogAccess.cc b/src/proxy/logging/LogAccess.cc
index a1cd9222c..f052d6be9 100644
--- a/src/proxy/logging/LogAccess.cc
+++ b/src/proxy/logging/LogAccess.cc
@@ -741,6 +741,74 @@ unmarshal_str_json(char **buf, char *dest, int len, LogSlice *slice)
   return -1;
 }
 
+static int
+escape_ltsv(char *dest, const char *buf, int len)
+{
+  int escaped_len = 0;
+
+  for (int i = 0; i < len; i++) {
+    char c  = buf[i];
+    if (c == '\\' || c == '\t' || c == '\n') { // escape.
+      if (dest) {
+        if (escaped_len + 2 > len) {
+          break;
+        }
+        *dest++ = '\\';
+        switch (c) {
+        case '\\': *dest++ = '\\'; break;
+        case '\t': *dest++ = 't'; break;
+        case '\n': *dest++ = 'n'; break;
+        }
+      }
+      escaped_len += 2;
+
+    } else {
+      if (dest) {
+        if (escaped_len + 1 > len) {
+          break;
+        }
+        *dest++ = c;
+      }
+      escaped_len++;
+    }
+  } // end for
+  return escaped_len;
+}
+
+int
+unmarshal_str_ltsv(char **buf, char *dest, int len, LogSlice *slice)
+{
+  Debug("log-escape", "unmarshal_str_ltsv start, len=%d, slice=%p", len, slice);
+
+  char *val_buf   = *buf;
+  int val_len     = static_cast<int>(::strlen(val_buf));
+  int escaped_len = escape_ltsv(nullptr, val_buf, val_len);
+
+  *buf += LogAccess::strlen(val_buf); // this is how it was stored
+
+  if (slice && slice->m_enable) {
+    int offset, n;
+
+    n = slice->toStrOffset(escaped_len, &offset);
+    Debug("log-escape", "unmarshal_str_ltsv start, n=%d, offset=%d", n, offset);
+    if (n <= 0) {
+      return 0;
+    }
+
+    if (n >= len) {
+      return -1;
+    }
+
+    return escape_ltsv(dest, (val_buf + offset), n);
+  }
+
+  if (escaped_len < len) {
+    escape_ltsv(dest, val_buf, escaped_len);
+    return escaped_len;
+  }
+  return -1;
+}
+
 } // end anonymous namespace
 
 /*-------------------------------------------------------------------------
@@ -762,6 +830,9 @@ LogAccess::unmarshal_str(char **buf, char *dest, int len, LogSlice *slice, LogEs
   if (LOG_ESCAPE_JSON == escape_type) {
     return unmarshal_str_json(buf, dest, len, slice);
   }
+  if (LOG_ESCAPE_LTSV == escape_type) {
+    return unmarshal_str_ltsv(buf, dest, len, slice);
+  }
 
   char *val_buf = *buf;
   int val_len   = static_cast<int>(::strlen(val_buf));
diff --git a/src/proxy/logging/YamlLogConfigDecoders.cc b/src/proxy/logging/YamlLogConfigDecoders.cc
index f414e6625..edcbe3b63 100644
--- a/src/proxy/logging/YamlLogConfigDecoders.cc
+++ b/src/proxy/logging/YamlLogConfigDecoders.cc
@@ -75,6 +75,8 @@ convert<std::unique_ptr<LogFormat>>::decode(const Node &node, std::unique_ptr<Lo
     std::string escape = node["escape"].as<std::string>();
     if (!strncasecmp(escape.c_str(), "json", 4)) {
       escape_type = LOG_ESCAPE_JSON;
+    } else if (!strncasecmp(escape.c_str(), "ltsv", 4)) {
+      escape_type = LOG_ESCAPE_LTSV;
     } else if (!strncasecmp(escape.c_str(), "none", 4)) {
       escape_type = LOG_ESCAPE_NONE;
     } else {
